// Work in progress. Much of the framework is built with AI. This is an attempt make a more efficient process for gathering the logs and potentially add more features like a switch for protectdiagnostics or uploads to third party file providers
// Currently does not have a results.html or MDM Check.txt. That is coming but slowly. Enjoy if you want to partake. Otherwise the Shell Script is still actively supported and not going anywhere.

import Foundation

let fileManager = FileManager.default

// MARK: - Helper Functions

func runCommand(_ command: String) -> String {
    let process = Process()
    let pipe = Pipe()

    process.executableURL = URL(fileURLWithPath: "/bin/zsh")
    process.arguments = ["-c", command]
    process.standardOutput = pipe
    process.standardError = pipe

    do {
        try process.run()
    } catch {
        print("‚ùå Failed to launch command: \(command)\n\(error.localizedDescription)")
        return ""
    }

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    return String(data: data, encoding: .utf8) ?? ""
}

func runAndSave(command: String, outputPath: String) {
    let output = runCommand(command)
    let outputURL = URL(fileURLWithPath: outputPath)

    do {
        try output.write(to: outputURL, atomically: true, encoding: .utf8)
        print("‚úÖ Saved command output to: \(outputPath)")
    } catch {
        print("‚ùå Failed to save output to \(outputPath): \(error.localizedDescription)")
    }
}

func copyItem(from sourcePath: String, to destinationPath: String) {
    let sourceURL = URL(fileURLWithPath: sourcePath)
    let destinationURL = URL(fileURLWithPath: destinationPath)

    guard fileManager.fileExists(atPath: sourcePath) else {
        print("‚ö†Ô∏è Source not found: \(sourcePath)")
        return
    }

    do {
        if fileManager.fileExists(atPath: destinationPath) {
            try fileManager.removeItem(at: destinationURL)
        }
        try fileManager.copyItem(at: sourceURL, to: destinationURL)
        print("‚úÖ Copied \(sourcePath) to \(destinationPath)")
    } catch {
        print("‚ùå Copy failed from \(sourcePath) to \(destinationPath): \(error.localizedDescription)")
    }
}

func createFolder(at path: String) {
    let folderURL = URL(fileURLWithPath: path)
    do {
        try fileManager.createDirectory(at: folderURL, withIntermediateDirectories: true, attributes: nil)
        print("üìÅ Created folder: \(path)")
    } catch {
        print("‚ùå Failed to create folder at \(path): \(error.localizedDescription)")
    }
}

// MARK: - User & Paths Setup

let loggedInUser = runCommand("stat -f%Su /dev/console").trimmingCharacters(in: .whitespacesAndNewlines)
let userHomeDirectory = "/Users/\(loggedInUser)"
let desktopDirectory = "\(userHomeDirectory)/Desktop"

// Timestamp & main folder
let formatter = DateFormatter()
formatter.dateFormat = "MM-dd-yyyy"
let dateString = formatter.string(from: Date())
let mainFolderName = "\(loggedInUser)_\(dateString)_logs"
let mainFolderPath = "\(desktopDirectory)/\(mainFolderName)"

// Rename existing folder if necessary
if fileManager.fileExists(atPath: mainFolderPath) {
    let oldFolderPath = "\(mainFolderPath)_old"
    do {
        if fileManager.fileExists(atPath: oldFolderPath) {
            try fileManager.removeItem(atPath: oldFolderPath)
        }
        try fileManager.moveItem(atPath: mainFolderPath, toPath: oldFolderPath)
        print("üì¶ Renamed existing folder to: \(oldFolderPath)")
    } catch {
        print("‚ùå Failed to rename existing folder: \(error.localizedDescription)")
    }
}

// MARK: - Create Folder Structure

createFolder(at: mainFolderPath)

let folders = [
    "Client_Logs",
    "Managed_Preferences",
    "Client_Logs/SoftwareUpdates",
    "Client_Logs/DDM",
    "Client_Logs/DiagnosticReports",
    "App_Installers",
    "Jamf_Security",
    "Device_Compliance",
    "Connect"
]

folders.forEach {
    createFolder(at: "\(mainFolderPath)/\($0)")
}

let clientLogsPath = "\(mainFolderPath)/Client_Logs"
let managedPrefsPath = "\(mainFolderPath)/Managed_Preferences"
let softwareUpdatesPath = "\(clientLogsPath)/SoftwareUpdates"
let ddmPath = "\(clientLogsPath)/DDM"
let jamfSecurityFolder = "\(mainFolderPath)/Jamf_Security"

// MARK: - Sudo Privileges Check

let isRoot = (getuid() == 0)
print(isRoot ? "‚úÖ Running with sudo privileges." : "‚ö†Ô∏è Warning: Not running with sudo. Some files may be inaccessible.")

// MARK: - File Gathering

copyItem(from: "/Library/Receipts/InstallHistory.plist", to: "\(clientLogsPath)/InstallHistory.plist")
copyItem(from: "/Library/Managed Preferences", to: managedPrefsPath)
copyItem(from: "\(userHomeDirectory)/Library/Logs/JAMF", to: "\(clientLogsPath)/SelfService")

let selfServicePlusAppPath = "/Applications/Self Service+.app"
if fileManager.fileExists(atPath: selfServicePlusAppPath) {
    let ssPlusLogCommand = """
    log show --style compact --predicate 'subsystem == "com.jamf.selfserviceplus"' --debug --info --last 1d
    """
    runAndSave(command: ssPlusLogCommand, outputPath: "\(clientLogsPath)/SelfService/SelfServicePlus.log")
} else {
    print("‚ÑπÔ∏è Self Service+ not installed.")
}

runAndSave(command: "system_profiler -xml", outputPath: "\(clientLogsPath)/SystemReport.spx")
runAndSave(command: "profiles show -output stdout-xml", outputPath: "\(clientLogsPath)/profiles.xml")

// MARK: - MDM Client Commands

let mdmCommands: [(String, String)] = [
    ("/usr/libexec/mdmclient AvailableOSUpdates", "\(softwareUpdatesPath)/AvailableOSUpdates.txt"),
    ("/usr/libexec/mdmclient QueryDeviceInformation", "\(clientLogsPath)/QueryDeviceInformation.txt"),
    ("/usr/libexec/mdmclient DumpManagementStatus", "\(clientLogsPath)/DumpManagementStatus.txt")
]

mdmCommands.forEach { runAndSave(command: $0.0, outputPath: $0.1) }

// MARK: - Additional Logs & Copies

runAndSave(command: "launchctl dumpstate", outputPath: "\(clientLogsPath)/launchctl_dumpstate.txt")
runAndSave(command: "systemextensionsctl list", outputPath: "\(clientLogsPath)/system_extensions.txt")
runAndSave(command: "kextstat", outputPath: "\(clientLogsPath)/kextstat.txt")
runAndSave(command: "cat /Library/Application\\ Support/JAMF/.jmf_settings.json", outputPath: "\(clientLogsPath)/restricted_software.json")

copyItem(from: "/System/Library/PrivateFrameworks/RemoteManagement.framework/XPCServices/SoftwareUpdateSubscriber.xpc/Contents/Info.plist", to: "\(softwareUpdatesPath)/ClientInfo.plist")
copyItem(from: "/private/var/db/softwareupdate/SoftwareUpdateDDMStatePersistence.plist", to: "\(softwareUpdatesPath)/DDM.plist")

// DDM XPC Info Plist collection
let xpcServicesPath = "/System/Library/PrivateFrameworks/RemoteManagement.framework/XPCServices"
if let xpcContents = try? fileManager.contentsOfDirectory(atPath: xpcServicesPath) {
    for item in xpcContents where item.hasSuffix(".xpc") && item != "SoftwareUpdateSubscriber.xpc" {
        let infoPlistPath = "\(xpcServicesPath)/\(item)/Contents/Info.plist"
        let destPlistPath = "\(ddmPath)/\(item)_Info.plist"
        copyItem(from: infoPlistPath, to: destPlistPath)
    }
}

copyItem(from: "/Library/Logs/DiagnosticReports", to: "\(clientLogsPath)/DiagnosticReports")

// MARK: - App Installers & Flagged Installs

copyItem(from: "/var/db/ConfigurationProfiles/Settings/Managed Applications/Device", to: "\(mainFolderPath)/App_Installers")

let completedPath = "/var/db/ConfigurationProfiles/Settings/Managed Applications/Device/_completed"
let flaggedFilesPath = "\(mainFolderPath)/App_Installers/Flagged_Installers.txt"

if fileManager.fileExists(atPath: completedPath) {
    do {
        let files = try fileManager.contentsOfDirectory(atPath: completedPath)
        let flaggedFiles = files.filter {
            let installFailedOutput = runCommand("defaults read '\(completedPath)/\($0)' InstallFailed")
            return installFailedOutput.trimmingCharacters(in: .whitespacesAndNewlines) == "1" || installFailedOutput.lowercased().contains("true")
        }

        let flaggedOutput = flaggedFiles.isEmpty ? "No failed installers found." : flaggedFiles.joined(separator: "\n")
        try flaggedOutput.write(toFile: flaggedFilesPath, atomically: true, encoding: .utf8)

        print("‚úÖ Flagged installers report saved at \(flaggedFilesPath)")
    } catch {
        print("‚ùå Error scanning _completed folder: \(error.localizedDescription)")
    }
} else {
    print("‚ö†Ô∏è No _completed folder found at \(completedPath)")
}

// MARK: - Jamf Security & Device Compliance Logs

if !runCommand("which protectctl").isEmpty {
    runAndSave(command: "protectctl info --verbose", outputPath: "\(mainFolderPath)/Jamf_Security/jamfprotectinfo.log")
} else {
    print("‚ö†Ô∏è protectctl not found on this system.")
}

runAndSave(command: "log show --predicate 'subsystem CONTAINS \"jamfAAD\" OR subsystem BEGINSWITH \"com.apple.AppSSO\"'", outputPath: "\(mainFolderPath)/Device_Compliance/JamfConditionalAccess.log")

// MARK: - Jamf Connect Logs

var jamfConnectBinary = runCommand("which jamfconnect").trimmingCharacters(in: .whitespacesAndNewlines)
if jamfConnectBinary.isEmpty, fileManager.fileExists(atPath: "/usr/local/bin/jamfconnect") {
    jamfConnectBinary = "/usr/local/bin/jamfconnect"
}

if !jamfConnectBinary.isEmpty {
    runCommand("\(jamfConnectBinary) -logs")

    let logsSource = "/Library/Application Support/JamfConnect/Logs"
    if let items = try? fileManager.contentsOfDirectory(atPath: logsSource),
       let zipFile = items.first(where: { $0.hasSuffix(".zip") }) {
        runCommand("unzip -o '\(logsSource)/\(zipFile)' -d '\(mainFolderPath)/Connect'")
        print("‚úÖ Extracted Jamf Connect logs.")
    } else {
        print("‚ö†Ô∏è Jamf Connect logs not found.")
    }
} else {
    print("‚ö†Ô∏è Jamf Connect binary not found. Skipping.")
}

// MARK: - Recon Folder for JAMF tmp

if runCommand("ps -acx | grep 'jamf$'").isEmpty {
    createFolder(at: "\(mainFolderPath)/Recon")
    copyItem(from: "/Library/Application Support/JAMF/tmp/", to: "\(mainFolderPath)/Recon")
} else {
    print("‚ö†Ô∏è Jamf process is running. Skipping Recon.")
}

// MARK: - Plist Conversion

func convertPlistToXMLSwift(inputPath: String) {
    guard let plistData = fileManager.contents(atPath: inputPath) else {
        print("‚ùå Failed to read plist at \(inputPath)")
        return
    }

    do {
        let plistObject = try PropertyListSerialization.propertyList(from: plistData, options: [], format: nil)
        let xmlData = try PropertyListSerialization.data(fromPropertyList: plistObject, format: .xml, options: 0)
        try xmlData.write(to: URL(fileURLWithPath: inputPath))
        print("‚úÖ Converted plist to XML: \(inputPath)")
    } catch {
        print("‚ùå Error converting plist at \(inputPath): \(error.localizedDescription)")
    }
}

func convertAllPlistsToXMLSwift(atPath path: String) {
    guard let enumerator = fileManager.enumerator(atPath: path) else {
        print("‚ùå Failed to enumerate: \(path)")
        return
    }

    for case let file as String in enumerator where file.hasSuffix(".plist") {
        convertPlistToXMLSwift(inputPath: "\(path)/\(file)")
    }
}

[clientLogsPath, managedPrefsPath, softwareUpdatesPath, ddmPath, "\(mainFolderPath)/App_Installers", "\(mainFolderPath)/Connect"]
    .forEach { convertAllPlistsToXMLSwift(atPath: $0) }
    
// Move Security Plists
    // Plist files to look for
    let securityPlists = ["com.jamf.trust.plist", "com.jamf.protect.plist"]
    
    for plist in securityPlists {
        let sourcePlistPath = "\(managedPrefsPath)/\(plist)"
        let destPlistPath = "\(jamfSecurityFolder)/\(plist)"
        
        if fileManager.fileExists(atPath: sourcePlistPath) {
            do {
                try fileManager.copyItem(atPath: sourcePlistPath, toPath: destPlistPath)
                print("‚úÖ Copied \(plist) from Managed_Preferences to Jamf_Security.")
            } catch {
                print("‚ùå Failed to copy \(plist): \(error.localizedDescription)")
            }
        } else {
            print("‚ö†Ô∏è \(plist) not found in Managed_Preferences.")
        }
    }

print("‚úÖ Log gathering complete! Files are saved to: \(mainFolderPath)")
